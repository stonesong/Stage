\section{Introduction}
\label{sec:intro}

L'apparition des premiers dépôts logiciels en libre accès dans les années 90 a rendu possibles de nombreux travaux de recherche sur l'évolution logicielle. Plus particulièrement avec les dépôts de code source gérés par des outils de contrôle de versions (Version Control System, VCS) tels que  SVN (2000), Mercurial (2005) ou encore Git (2005) qui contiennent l'historique de construction d'un logiciel.\\  

C'est principalement dans le domaine de la maintenance et évolution logicielle, qui permet de comprendre les choix des développeurs lors de la création d'un logiciel, qu'il existe des études se basant sur l'analyse de ces historiques. Elles entrent dans le cadre des études ``MSR'' (Minning Software Repository).

La prédiction de bugs, un des défis connus du Génie Logiciel dont le but est de prédire le nombre de bugs et leurs localisations dans la version d'un logiciel avant son déploiement, utilise des informations contenues dans l'historique d'un projet. Un grand nombre d'étude sur ce sujet tentent de trouver les meilleures métriques, sur les propriétés techniques ou fonctionnelles d'un logiciel, qui serviront de prédicateurs de bugs~\cite{fenton_critique_1999}.

Nagappan et al. dans l'article ~\cite{nagappan_mining_2006} montrent que ni les métriques tels que le nombre de ligne de code (LOC, Line Of Code) ni les métriques orientées objets tels que l'arbre d'héritage (DIT) ne peuvent être utilisés dans tous les logiciels. Depuis, beaucoup d'études plus récentes montrent que les métriques de procédés (software change metrics) donnent de bien meilleurs résultats ~\cite{nagappan_use_2005,weyuker_too_2008,bird_dont_2011,giger_can_2012}.\\

Les métriques de procédés se concentrent sur l'évolution d'un logiciel et mesurent les modifications subies par les entités d'un code source durant leur cycle de vie. L'hypothèse principale est que la manière dont les entités du code ont changé a un impact majeur sur leur qualité et donc sur les bugs qu'elles peuvent contenir. Il est donc primordial que les valeurs des métriques de procédés représentent au plus proche la réalité des changements.

Dans l'article \cite{radjenovic_software_2013}, Radjenovic et al.identifient les trois métriques de procédés les plus utilisés. Le nombre de développeurs ~\cite{weyuker_too_2008} (Number of Developers, NoD), le nombre de modifications ~\cite{graves_predicting_2000} (Number of Changes, NoC) et le Code Churn ~\cite{munson_code_1998} (CC). NoD compte le nombre de développeurs qui ont contribués à une entité. NoC compte le nombre de changements qu'a subi une entité. CC compte le nombre de lignes de code qui ont été ajoutées ou supprimées à une entité.\\
 

Calculer les métriques de procédés paraît simple à première vue. Pour un logiciel donné, cela consiste à observer tous les changements subis par chaque entité qu'il contient. Dans ce but, l'utilisation d'un gestionnaire de version est indispensable car il permet de suivre les changements effectués par tous les développeurs sur toutes les entités. 

Or au cours de son histoire, une entité du code source tel qu'un fichier, peut être renommée et/ou déplacée dans un autre dossier du projet. Ces actions sont peu ou pas prises en compte par les VCS ce qui rend le calcul des métriques plus délicat et sujet aux erreurs.\\

Théoriquement, si le renommage d'une entité à un moment donné de son histoire n'est pas pris en compte, le calcul d'une métrique de procédé sur ce fichier sera faussé. En effet, dans le cas où un fichier est identifié par son nom, les informations disponibles avant le renommage seront perdues. Par ailleurs, il est de notoriété commune que les refactorings, modifications architecturales qui permettent d'améliorer le code source (dont le renommage de fichiers) sont très utilisés au cours de la construction des logiciels. En pratique, nous ne connaissons pas la quantité de renommage ni son impact sur les métriques de procédés.\\

L’objet de nos travaux est donc d’étudier le phénomène du renommage et son impact sur les métriques de procédés. Nous présentons une étude empirique approfondie sur cinq projets open-source connus et matures avec l'intention de donner une idée du montant d'entités renommés dans les logiciels. De plus, nous étudions l'impact du renommage d'entités en calculant les trois métriques de procédés les plus utilisés sur les projets de notre corpus avec et sans considération du renommage d'entités. Nos résultats indiquent que la quantité de renommage qui apparait dans les projets peut être importante. Nous avons observé jusqu'à $99\%$ d'entités renommés dans un projet. Nous avons aussi observé qu'il peut affecter les valeurs des métriques de procédés de manière significative, et par conséquent qu'il peut être une menace sérieuse d'études utilisant ces métriques. Basé sur nos observations, nous proposons une brève analyse de l'impact possible du renommage sur les études antérieures sur la prédiction de bugs. Nous proposons enfin de simples lignes de conduite qui aideront les chercheurs et développeurs à mieux calculer les métriques de procédés.\\


Pour résumer les contributions que nous apportons:
\begin{itemize}
\item Une étude empirique du renommage d'entités sur cinq projets open-source populaires.    
\item Des informations détaillées sur la quantité de renommage.
\item Une analyse de l'impact du renommage sur les métriques de procédés.
\item Une analyse des études antérieures qui utilisent les métriques de procédés pour la prédiction de bugs, afin d'évaluer si elles peuvent être biaisés par le renommage. 
\item Quelques lignes de conduite essentielles afin de limiter les risques lors des calculs des métriques de procédés.\\
\end{itemize}


Les résultats de nos expérimentations nous ont amenés à proposer un article pour la conférence internationale ICSME 2014.

