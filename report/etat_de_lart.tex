\section{Etat de l'art}
\label{sec:etat_de_lart}

\subsection{Evolution logiciel et refactoring}
On peut régulièrement lire en introduction d'articles des propos sur l'importance du refactoring, ce qui inclue le renommage, dans les projets à succès (TODO) mais on obtient pas de chiffres précis.\\

\subsection{Métriques de procédés et évolution logiciel}
Les métriques de procédés (change metrics) permettent de calculer à quel point une entité de code source à été modifiée au cours d'une période donnée dans l'histoire d'un logiciel. On les utilises usuellement dans la dernière période avant la dernière version, l'objectif étant de prédire les bugs qui apparaitront lors de la prochaine release. Elles ne considère donc que les entités étant toujours présentes à la fin de la période et qui ont étés actives dans la période.\\
Radjenovic et al \cite{radjenovic_software_2013} identifient trois métriques de procédés les plus utilisés pour la prédiction de bugs: Le nombre de développeurs ~\cite{weyuker_too_2008} (Number of Developers, NoD), Le nombre de modifications ~\cite{graves_predicting_2000} (Number of Changes, NoC) et le Code Churn ~\cite{munson_code_1998} (CC). Nous donnerons une définition et une méthode précise pour les calculer dans nos expérimentations.\\

\subsection{Métriques et Renommage Existant}
Nous nous somme donc intéressés aux études passées qui pouvaient traiter les métriques de procédés dans la prédiction de bugs, et vérifié si ces études avaient considérés le renommage de fichiers. L'article (TODO) référence 26 articles qui nous intéresse, 15 sur des projets industriels, 11 sur des logiciels open-source. TODO \\

\subsection{Les outils}
Comme nous l'avons vue, il existe un certains nombre de gestionnaires de versions pour effectuer notre détection de renommage, étant donné que nous avons simplement besoin de versions à comparer. Nous avons néhanmoins étudié les VCS potentiels, afin de voir quel VCS sera le plus apte à gérer les renommages. La table1 résume notre étude. TODO Git propose un algorithme de détection automatique de renommage.\\

\subsection{``Origin Analysis''}
L'algorithme utilisé par Git est connu sous sous le nom de ``Origin Analysis'' et est expliqué par Godfrey et al dans les articles, (TODO) (An integrated approach for studying architectural evolution, Tracking Structural Evolution Using Origin Analysis, Using origin analysis to detect merging and splitting of source code entities)
Origin Analysis TODO\\

\begin{table}
\centering
\begin{tabular}{rccc}
\toprule
 & \multicolumn{3}{c}{Renaming handling}\\
\cmidrule{2-4}
& & \multicolumn{2}{c}{Automatic}\\
\cmidrule{3-4}
Tool & Manual & Standard & Optional\\
\midrule
CVS & & &\\
Subversion & $\times$ & &\\
Mercurial & $\times$ & & $\times$\\
Git & & & $\times$\\
\bottomrule
\end{tabular}
\caption{Handling of renaming of the main VCS tools.}
\label{tab:vcs}
\end{table}
